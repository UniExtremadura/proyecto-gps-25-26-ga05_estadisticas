/*
 * Microservicio de Estadisticas - GA04
 *
 * Especificacion OpenAPI del microservicio de \"Estadisticas\" dentro del proyecto \"Undersounds\" de GPS/ASEE.  El codigo del proyecto esta disponible en el [repositorio de GitHub](https://github.com/UniExtremadura/proyecto-gps-25-26-ga05).
 *
 * API version: 0.1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gocql/gocql"
)

type UsuariosAPI struct {
	DB *gocql.Session
}

// Get /usuarios/:idUsuario/estadisticas
// Obtener estadisticas de consumo de un usuario
func (api *UsuariosAPI) UsuariosIdUsuarioEstadisticasGet(c *gin.Context) {
	idUsuarioStr := c.Param("idUsuario")
	idUsuario, err := strconv.Atoi(idUsuarioStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"status": "error", "message": "idUsuario inválido"})
		return
	}

	// Obtener parámetro de periodo
	periodo := c.DefaultQuery("periodo", "total")

	// Calcular fechas según el periodo
	var fechaFiltro time.Time
	now := time.Now()
	
	switch periodo {
	case "mes":
		fechaFiltro = now.AddDate(0, -1, 0)
	case "anno":
		fechaFiltro = now.AddDate(-1, 0, 0)
	}

	// Contadores
	var totalEscuchas int32
	var totalComprasAlbumes int32
	var totalComprasMerch int32

	// Contar escuchas
	if periodo == "total" {
		// Contar todas las escuchas
		var count int
		if err := api.DB.Query(`SELECT COUNT(*) FROM escucha WHERE idUsuario = ?`, int32(idUsuario)).Scan(&count); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error contando escuchas: " + err.Error()})
			return
		}
		totalEscuchas = int32(count)
	} else {
		// Contar escuchas con filtro de fecha
		iter := api.DB.Query(`SELECT idCancion, fecha FROM escucha WHERE idUsuario = ?`, int32(idUsuario)).Iter()
		var idCancion int32
		var fecha time.Time
		
		for iter.Scan(&idCancion, &fecha) {
			if fecha.After(fechaFiltro) {
				totalEscuchas++
			}
		}
		if err := iter.Close(); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error procesando escuchas: " + err.Error()})
			return
		}
	}

	// Contar compras de álbumes
	if periodo == "total" {
		// Contar todas las compras de álbumes
		var count int
		if err := api.DB.Query(`SELECT COUNT(*) FROM compraAlbum WHERE idUsuario = ?`, int32(idUsuario)).Scan(&count); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error contando compras de álbumes: " + err.Error()})
			return
		}
		totalComprasAlbumes = int32(count)
	} else {
		// Contar compras de álbumes con filtro de fecha
		iter := api.DB.Query(`SELECT idAlbum, fecha FROM compraAlbum WHERE idUsuario = ?`, int32(idUsuario)).Iter()
		var idAlbum int32
		var fecha time.Time
		
		for iter.Scan(&idAlbum, &fecha) {
			if fecha.After(fechaFiltro) {
				totalComprasAlbumes++
			}
		}
		if err := iter.Close(); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error procesando compras de álbumes: " + err.Error()})
			return
		}
	}

	// Contar compras de merchandising
	if periodo == "total" {
		// Contar todas las compras de merchandising
		var count int
		if err := api.DB.Query(`SELECT COUNT(*) FROM compraMerch WHERE idUsuario = ?`, int32(idUsuario)).Scan(&count); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error contando compras de merchandising: " + err.Error()})
			return
		}
		totalComprasMerch = int32(count)
	} else {
		// Contar compras de merchandising con filtro de fecha
		iter := api.DB.Query(`SELECT idMerch, fecha FROM compraMerch WHERE idUsuario = ?`, int32(idUsuario)).Iter()
		var idMerch int32
		var fecha time.Time
		
		for iter.Scan(&idMerch, &fecha) {
			if fecha.After(fechaFiltro) {
				totalComprasMerch++
			}
		}
		if err := iter.Close(); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error procesando compras de merchandising: " + err.Error()})
			return
		}
	}

	estadisticas := EstadisticasUsuario{
		IdUsuario:          int32(idUsuario),
		TotalEscuchas:      totalEscuchas,
		TotalComprasAlbumes: totalComprasAlbumes,
		TotalComprasMerch:  totalComprasMerch,
	}

	c.JSON(http.StatusOK, estadisticas)
}

// Get /usuarios/:idUsuario/historialCompras
// Obtener historial de compras de un usuario
func (api *UsuariosAPI) UsuariosIdUsuarioHistorialComprasGet(c *gin.Context) {
	idUsuarioStr := c.Param("idUsuario")
	idUsuario, err := strconv.Atoi(idUsuarioStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"status": "error", "message": "idUsuario inválido"})
		return
	}

	historial := HistorialCompras{}

	// --- Compras de álbumes ---
	var historialAlbum []HistorialComprasAlbumes
	iterAlbum := api.DB.Query(`SELECT idAlbum, fecha FROM compraAlbum WHERE idUsuario = ?`, int32(idUsuario)).Iter()
	var idAlbum int32
	var fechaAlbum time.Time
	for iterAlbum.Scan(&idAlbum, &fechaAlbum) {
		nombre, urlImagen, err := fetchAlbumContenido(idAlbum)
		if err != nil {
			fmt.Printf("Error fetchAlbumContenido para idAlbum=%d: %v\n", idAlbum, err)
			c.JSON(http.StatusInternalServerError, gin.H{
				"status":  "error",
				"message": fmt.Sprintf("error obteniendo información de álbum: %v", err),
			})
			return
		}

		historialAlbum = append(historialAlbum, HistorialComprasAlbumes{
			IdAlbum:   idAlbum,
			Fecha:     fechaAlbum.Format(time.RFC3339),
			Nombre:    nombre,
			UrlImagen: urlImagen,
		})
	}

	if err := iterAlbum.Close(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}
	historial.ComprasAlbumes = historialAlbum

	// --- Compras de merchandising ---
	var historialMerch []HistorialComprasMerchandising
	iterMerch := api.DB.Query(`SELECT idMerch, fecha FROM compraMerch WHERE idUsuario = ?`, int32(idUsuario)).Iter()
	var idMerch int32
	var fechaMerch time.Time
	for iterMerch.Scan(&idMerch, &fechaMerch) {
		nombre, urlImagen, err := fetchMerchContenido(idMerch)
		if err != nil {
			fmt.Printf("Error fetchMerchContenido para idMerch=%d: %v\n", idMerch, err)
			c.JSON(http.StatusInternalServerError, gin.H{
				"status":  "error",
				"message": fmt.Sprintf("error obteniendo información de merchandising: %v", err),
			})
			return
		}

		historialMerch = append(historialMerch, HistorialComprasMerchandising{
			IdMerch:   idMerch,
			Fecha:     fechaMerch.Format(time.RFC3339),
			Nombre:    nombre,
			UrlImagen: urlImagen,
		})
	}

	if err := iterMerch.Close(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}
	historial.ComprasMerchandising = historialMerch

	c.JSON(http.StatusOK, gin.H{
		"status":    "OK",
		"historial": historial,
	})
}

func fetchAlbumContenido(id int32) (string, string, error) {
	resp, err := http.Get(fmt.Sprintf("http://contenido-app:8080/albums/%d", id))
	if err != nil {
		return "", "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", "", fmt.Errorf("servicio de contenido devolvió código %d", resp.StatusCode)
	}

	// Decodificamos DIRECTAMENTE el Album que devuelve el microservicio
	var album struct {
		Nombre string `json:"nombre"`
		Imagen []byte `json:"imagen"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&album); err != nil {
		return "", "", err
	}

	// Convertimos la imagen a base64
	urlImagen := ""
	if len(album.Imagen) > 0 {
		urlImagen = "data:image/jpeg;base64," + base64.StdEncoding.EncodeToString(album.Imagen)
	}

	return album.Nombre, urlImagen, nil
}

func fetchMerchContenido(id int32) (string, string, error) {
	resp, err := http.Get(fmt.Sprintf("http://contenido-app:8080/merch/%d", id))
	if err != nil {
		return "", "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", "", fmt.Errorf("servicio de contenido devolvió código %d", resp.StatusCode)
	}

	var data struct {
		Status string `json:"status"`
		Merch  struct {
			Nombre string `json:"nombre"`
			Imagen string `json:"imagen"` // campo en Base64
		} `json:"merch"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return "", "", err
	}

	// Construir URL data:image/jpeg;base64
	var urlImagen string
	if data.Merch.Imagen != "" {
		urlImagen = fmt.Sprintf("data:image/jpeg;base64,%s", data.Merch.Imagen)
	}

	return data.Merch.Nombre, urlImagen, nil
}
